// Copyright (C) 2024 [Kulpreet Singh]
//
//  This file is part of P2Poolv2
//
// P2Poolv2 is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
//
// P2Poolv2 is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with
// P2Poolv2. If not, see <https://www.gnu.org/licenses/>.

use crate::node::behaviour::request_response::RequestResponseEvent;
use crate::node::messages::Message;
use crate::node::Node;
use crate::shares::chain::ChainHandle;
use std::error::Error;
use tracing::{debug, error, info};

/// Request-response handler for Node
impl Node {
    /// Handle request-response events, these are events that are generated by the request-response protocol
    /// TODO: We are handling requeuests in serial, we should change this to allow concurrent handling of requests
    pub async fn handle_request_response_event(
        self: &mut Node,
        event: RequestResponseEvent<Message, Message>,
    ) -> Result<(), Box<dyn Error>> {
        info!("Request-response event: {:?}", event);
        match event {
            RequestResponseEvent::Message {
                peer,
                message:
                    libp2p::request_response::Message::Request {
                        request_id,
                        request,
                        channel,
                    },
            } => {
                debug!(
                    "Received request with id: {} from peer: {}",
                    request_id, peer
                );
                if let Err(e) = self
                    .handle_request(peer, request_id, request, channel)
                    .await
                {
                    error!("Failed to handle request: {}", e);
                    return Err("Error handling request".into());
                }
            }
            RequestResponseEvent::Message {
                peer,
                message:
                    libp2p::request_response::Message::Response {
                        request_id,
                        response,
                    },
            } => {
                debug!(
                    "Received response for request: {} from peer: {}",
                    request_id, peer
                );
            }
            RequestResponseEvent::OutboundFailure {
                peer,
                request_id,
                error,
            } => {
                debug!("Outbound failure from peer: {peer}, request_id: {request_id}, error: {error:?}");
            }
            RequestResponseEvent::InboundFailure {
                peer,
                request_id,
                error,
            } => {
                debug!(
                    "Inbound failure from peer: {peer}, request_id: {request_id}, error: {error:?}"
                );
            }
            RequestResponseEvent::ResponseSent { peer, request_id } => {
                debug!("Response sent to peer: {peer}, request_id: {request_id}");
            }
        }
        Ok(())
    }

    async fn handle_request(
        self: &mut Node,
        peer: libp2p::PeerId,
        request_id: libp2p::request_response::InboundRequestId,
        request: Message,
        channel: libp2p::request_response::ResponseChannel<Message>,
    ) -> Result<(), Box<dyn Error>> {
        info!(
            "Handling request with id: {} from peer: {}",
            request_id, peer
        );
        match request {
            Message::ShareBlock(share_block) => {
                info!("Received share block: {:?}", share_block);
                if let Err(e) = share_block
                    .miner_share
                    .validate(share_block.miner_share.diff, share_block.miner_share.sdiff)
                {
                    error!("Share block validation failed: {}", e);
                    return Err("Share block validation failed".into());
                }
                if let Err(e) = self.chain_handle.add_share(share_block.clone()).await {
                    error!("Failed to add share: {}", e);
                    return Err("Error adding share to chain".into());
                }
                let buf = Message::ShareBlock(share_block).cbor_serialize().unwrap();
                if let Err(e) = self.send_gossip(buf) {
                    error!("Failed to send share: {}", e);
                    return Err("Error sending share to network".into());
                }
                Ok(())
            }
            Message::Workbase(workbase) => {
                info!("Received workbase: {:?}", workbase);
                if let Err(e) = self.chain_handle.add_workbase(workbase.clone()).await {
                    error!("Failed to store workbase: {}", e);
                    return Err("Error storing workbase".into());
                }
                let buf = Message::Workbase(workbase).cbor_serialize().unwrap();
                if let Err(e) = self.send_gossip(buf) {
                    error!("Failed to send share: {}", e);
                    return Err("Error sending share to network".into());
                }
                Ok(())
            }
            _ => {
                info!("Received unknown request: {:?}", request);
                Ok(())
            }
        }
    }
}
